import { DateTime } from 'luxon';
import { Plugin } from '../../model/plugin';
import { Mod } from '../../model/tag';

export const aiQueryPlugin: Plugin = {
  tag: 'plugin/delta/ai',
  name: $localize`✨️💭️ AI Query`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    description: $localize`Send this Ref to the ai for response.`,
    timeoutMs: 300_000,
    language: 'javascript',
    // language=JavaScript
    script: `
      const { Buffer } = require('buffer');
      const uuid = require('uuid');
      const axios = require('axios');
      const ref = JSON.parse(require('fs').readFileSync(0, 'utf-8'));
      const origin = ref.origin || ''
      const config = ref.plugins?.['plugin/delta/ai'] || {};
      const followup = ref.tags.includes('+plugin/delta/ai');
      const authors = ref.tags.filter(tag => tag === '+user' || tag === '_user' || tag.startsWith('+user/') || tag.startsWith('_user/'));
      const response = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Tag': authors[0] || '',
        },
        params: {
          query: '+plugin/placeholder:!+plugin/delta:' + authors.map(a => a.substring(1)).join(':'),
          responses: ref.url,
          size: 1,
        },
      })).data.content[0];
      if (!response) {
        // No placeholder, earlier stage failed
        process.exit(0);
      }
      const bundleSchema = {
        type: 'object',
        properties: {
          ref: {
            type: 'array',
            minItems: 1,
            items: {
              type: 'object',
              properties: {
                url: { type: 'string' },
                title: { type: 'string' },
                comment: { type: 'string' },
                tags: { type: 'array', items: { type: 'string' } },
                sources: { type: 'array', items: { type: 'string' } },
                alternateUrls: { type: 'array', items: { type: 'string' } },
                plugins: { type: 'object' },
                published: { type: 'string' },
              }
            }
          },
          ext: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                tag: { type: 'string' },
                name: { type: 'string' },
                config: { type: 'object' },
              },
              required: ['tag']
            }
          }
        }
      };
      const providers = {
        openai: {
          init(config) {
            config.model ||= config.vision ? 'o1' : config.audio ? 'gpt-4o-audio-preview' : 'o3-mini';
            config.maxTokens ||= 4096;
            config.thinking = false;
            config.pdf = false;
            config.image = ['o1', 'gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo'].includes(config.model);
            config.audio = config.model === 'gpt-4o-audio-preview';
            config.video = false;
          },
          loadMessage(source, plugins) {
            // TODO: OpenAI and X supports fetching images itself
            const message = {};
            message.content = [{ type: 'text', text: JSON.stringify(source) }];
            if (plugins['plugin/audio']) {
              message.content.push({
                type: 'input_audio',
                input_audio: {
                  data: Buffer.from(plugins['plugin/audio'].data, 'binary').toString('base64'),
                  format: plugins['plugin/audio'].headers['content-type'] === 'audio/mpeg' ? 'mp3' :
                          plugins['plugin/audio'].headers['content-type'] === 'audio/wav'  ? 'wav' : 'mp3',
                }
              });
            }
            if (plugins['plugin/image']) {
              message.content.push({
                type: 'image_url',
                image_url: {
                  url: 'data:' + plugins['plugin/image'].headers['content-type'] + ';base64,' + Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
                  detail: 'auto',
                }
              });
            }
            return message;
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey });
            const res = await openai.chat.completions.create({
              model: config.model,
              max_completion_tokens: config.maxTokens,
              response_format: { 'type': config.audio ? 'text' : 'json_object' },
              messages,
            });
            return {
              completion: res.choices[0]?.message?.content,
              usage: res.usage,
            };
          }
        },
        x: {
          init(config) {
            config.model ||= config.vision ? 'grok-2-vision-latest' : 'grok-2-latest';
            config.maxTokens ||= 4096;
            config.thinking = false;
            config.pdf = false;
            config.image = config.model === 'grok-2-vision-latest';
            config.audio = false;
            config.video = false;
          },
          loadMessage(source, plugins) {
            return providers['openai'].loadMessage(source, plugins);
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey, baseURL: 'https://api.x.ai/v1' });
            const res = await openai.chat.completions.create({
              model: config.model,
              max_completion_tokens: config.maxTokens,
              response_format: { 'type': 'json_object' },
              messages,
            });
            return {
              completion: res.choices[0]?.message?.content,
              usage: res.usage,
            };
          }
        },
        ds: {
          init(config) {
            config.model ||= config.thinking ? 'deepseek-reasoner' : 'deepseek-chat';
            config.maxTokens ||= 4096;
            config.thinking = config.model === 'deepseek-reasoner';
            config.image = false;
            config.audio = false;
            config.video = false;
          },
          loadMessage(source, plugins) {
            return providers['openai'].loadMessage(source, plugins);
          },
          async generate(messages, config) {
            const OpenAi = require('openai');
            const openai = new OpenAi({ apiKey, baseURL: 'https://api.deepseek.com' });
            const res = await openai.chat.completions.create({
              model: config.model,
              max_completion_tokens: config.maxTokens,
              response_format: config.thinking ? undefined : { 'type': 'json_object' },
              messages,
            });
            return {
              completion: res.choices[0]?.message?.content,
              usage: res.usage,
            };
          }
        },
        anthropic: {
          init(config) {
            config.model ||= 'claude-3-7-sonnet-latest';
            config.maxTokens ||= 4096;
            config.thinkingTokens ||= 4096
            config.pdf = true;
            config.image = true;
            config.audio = false;
            config.video = false;
          },
          loadMessage(source, plugins) {
            const message = {};
            message.content = [{
              type: 'text',
              text: JSON.stringify(source),
            }];
            if (plugins['plugin/pdf']) {
              message.content.push({
                type: 'document',
                source: {
                  type: 'base64',
                  media_type: plugins['plugin/pdf'].headers['content-type'] || 'application/pdf',
                  data: Buffer.from(plugins['plugin/pdf'].data, 'binary').toString('base64'),
                },
                cache_control: { type: 'ephemeral' },
              });
            }
            if (plugins['plugin/image']) {
              message.content.push({
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: plugins['plugin/image'].headers['content-type'] || 'image/png',
                  data: Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
                },
                cache_control: { type: 'ephemeral' },
              });
            }
            return message;
          },
          async generate(messages, config) {
            const Anthropic = require('@anthropic-ai/sdk');
            const anthropic = new Anthropic({ apiKey });
            const system = messages.filter(m => m.role === 'system').map(m => m.content).join("\\n\\n");
            const thinking = config.thinking ? {
              thinking: {
                type: 'enabled',
                budget_tokens: config.thinkingTokens,
              }
            } : {};
            const toolUse = !config.thinking ? {
              tools: [{
                name: 'bundle',
                description: 'JSON responses in bundle format',
                input_schema: bundleSchema,
              }],
              tool_choice: { type: 'tool', name: 'bundle' },
            } : {};
            const res = await anthropic.messages.create({
              model: config.model,
              max_tokens: config.maxTokens + (config.thinking ? config.thinkingTokens : 0),
              system,
              ...thinking,
              ...toolUse,
              messages: messages.filter(m => m.role !== 'system'),
            });
            let text = res.content.filter(t => t.type === 'text');
            const tools = res.content.filter(t => t.type === 'tool_use');
            return {
              completion: JSON.stringify(thinking ? { comment: text[0]?.text || '' } : tools[0]?.input),
              usage: {
                'prompt_tokens': res.usage.input_tokens,
                'completion_tokens': res.usage.output_tokens,
                'total_tokens': res.usage.input_tokens + res.usage.output_tokens,
              },
            };
          }
        },
        gemini: {
          init(config) {
            config.model ||= 'gemini-2.0-flash';
            config.pdf = false;
            config.image = true;
            config.audio = true;
            config.video = true;
          },
          loadMessage(source, plugins) {
            const message = {};
            message.parts = [{ text: JSON.stringify(source) }];
            if (plugins['plugin/audio']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/audio'].headers['content-type'] || 'image/mpeg',
                  data: Buffer.from(plugins['plugin/audio'].data, 'binary').toString('base64'),
                }
              });
            }
            if (plugins['plugin/video']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/video'].headers['content-type'] || 'video/mp4',
                  data: Buffer.from(plugins['plugin/video'].data, 'binary').toString('base64'),
                }
              });
            }
            if (plugins['plugin/image']) {
              message.parts.push({
                inlineData: {
                  mimeType: plugins['plugin/image'].headers['content-type'] || 'image/png',
                  data: Buffer.from(plugins['plugin/image'].data, 'binary').toString('base64'),
                }
              });
            }
            return message;
          },
          async generate(messages, config) {
            const { GoogleGenerativeAI } = require('@google/generative-ai');
            const genAI = new GoogleGenerativeAI(apiKey);
            const system = messages.filter(m => m.role === 'system').map(m => m.parts[0].text).join("\\n\\n");
            const model = genAI.getGenerativeModel({ model: config.model });
            const result = await model.generateContent({
              contents: messages.filter(m => m.role !== 'system'),
              systemInstruction: system,
            });
            let text = result.response.text().trim();
            while (text && !text.startsWith('{')) text = text.substring(1).trim();
            while (text && !text.endsWith('}')) text = text.substring(0, text.length - 1).trim();
            return {
              completion: text,
              usage: {
                prompt_tokens: result.response.usageMetadata.promptTokenCount,
                completion_tokens: result.response.usageMetadata.candidatesTokenCount,
                total_tokens: result.response.usageMetadata.totalTokenCount,
              },
            };
          }
        },
      };
      const provider = providers[config.provider ||= 'gemini'];
      provider.init(config);
      const apiKey = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Role': 'ROLE_ADMIN',
        },
        params: { query: (config.apiKeyTag ||= ('+plugin/secret/' + config.provider)) + origin },
      })).data.content[0]?.comment;
      const messages = [];
      if (response.sources.includes('system:ext-prompt')) {
        const exts = new Map();
        const getExt = async tag => {
          try {
            return (await axios.get(process.env.JASPER_API + '/api/v1/ext', {
              headers: {
                'Local-Origin': origin || 'default',
                'User-Tag': authors[0] || '',
              },
              params: { tag: tag + origin },
            })).data;
          } catch (e) {
            return null;
          }
        };
        const loadTags = async tags => {
          for (const t of tags || []) {
            if (exts.has(t)) continue;
            // TODO: handle missing ext error?
            const ext = await getExt(t);
            if (ext) exts.set(t, ext);
          }
        }
        await loadTags(response.tags);
        await loadTags(response.sources.filter(t => t.startsWith('tag:/')).map(t => t.substring('tag:/'.length)));
        if (exts.length) {
          messages.push({
            role: 'system',
            ...provider.loadMessage({ url: 'system:ext-prompt', origin, title: 'Ext Sources', comment: JSON.stringify(exts) }),
          });
        }
      }
      if (config.systemPrompt) {
        messages.push({
          role: 'system',
          ...provider.loadMessage({ url: 'system:app-prompt-override', origin, title: 'App Prompt Override', comment: config.systemPrompt }),
        });
      }
      const folderTags = (ref.tags || []).filter(t => t === 'folder' || t.startsWith('folder/'))
      if (folderTags.length) {
        const workspace = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
          headers: {
            'Local-Origin': origin || 'default',
            'User-Tag': authors[0] || '',
          },
          params: {
            query: folderTags.join(':') + (origin || '@'),
            sort: 'published',
            size: config.maxSources,
          },
        })).data.content;
        for (const w of workspace) {
          const role
            = w.tags?.includes('+system/prompt') ? 'system'
            : w.tags?.includes('+plugin/delta/ai/navi') ? 'assistant'
              : 'user';
          messages.push({
            role,
            ...provider.loadMessage(w),
          });
        }
      }
      const sources = (await axios.get(process.env.JASPER_API + '/api/v1/ref/page', {
        headers: {
          'Local-Origin': origin || 'default',
          'User-Tag': authors[0] || '',
        },
        params: {
          query: '!+system/prompt/placeholder',
          sources: response.url,
          sort: 'published',
          size: config.maxSources,
        },
      })).data.content;
      for (const c of sources) {
        const plugins = {};
        if (config.pdf && c.tags?.includes('plugin/pdf')) {
          const url = c.plugins?.['plugin/pdf']?.url || c.url;
          plugins['plugin/pdf'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        if (config.image && c.tags?.includes('plugin/image')) {
          const url = c.plugins?.['plugin/image']?.url || c.url;
          plugins['plugin/image'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        if (config.audio && c.tags?.includes('plugin/audio')) {
          const url = c.plugins?.['plugin/audio']?.url || c.url;
          plugins['plugin/audio'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        if (config.video && c.tags?.includes('plugin/video')) {
          const url = c.plugins?.['plugin/video']?.url || c.url;
          plugins['plugin/video'] = await axios.get(process.env.JASPER_API + '/pub/api/v1/repl/cache', {
            responseType: 'arraybuffer',
            headers: {
              'Local-Origin': origin || 'default',
              'User-Tag': authors[0] || '',
            },
            params: { url, origin: c.origin || '' },
          });
        }
        const role
          = c.tags?.includes('+system/prompt') ? 'system'
          : c.tags?.includes('+plugin/delta/ai/navi') ? 'assistant'
            : 'user';
        messages.push({
          role,
          ...provider.loadMessage(c, plugins),
        });
      }
      let { completion, usage } = await provider.generate(messages, config);
      let bundle;
      if (!completion) {
        throw 'Error: No completion in response'
      }
      try {
        bundle = JSON.parse(completion);
        if (!bundle.ref) {
          // Model returned a bare Ref?
          bundle = {
            ref: [bundle],
          };
        }
      } catch (e) {
        console.error('Error parsing completion:', e);
        console.error(completion);
        process.exit(1);
      }
      const completionRef = bundle.ref[0];
      if (!completionRef) {
        console.error('No ref');
        console.error(completion);
        process.exit(1);
      }
      bundle.ref[0] = response;
      delete response.metadata;
      response.title = completionRef.title || '';
      response.comment = completionRef.comment || '';
      response.plugins ||= {};
      response.plugins['+plugin/delta/ai'] = {
        provider: config.provider,
        model: config.model,
        maxTokens: config.maxTokens,
        thinking: config.thinking,
        thinkingTokens: config.thinkingTokens,
        vision: config.vision,
        audio: config.audio,
        usage: {
          promptTokens: usage.prompt_tokens,
          completionTokens: usage.completion_tokens,
          totalTokens: usage.total_tokens,
        },
      };
      const chatTags = ref.tags.filter(t => t === 'chat' || t.startsWith('chat/'));
      if (!chatTags.length){
        const mailboxes = ref.tags.filter(tag => tag.startsWith('plugin/inbox') || tag.startsWith('plugin/outbox'));
        response.tags.push(...mailboxes, ...authors.map(tag => 'plugin/inbox/' + tag.substring(1)));
      }
      const uniq = (v, i, a) => a.indexOf(v) === i;
      response.tags = [...response.tags, ...completionRef.tags || [], '+plugin/delta/ai'].filter(uniq).filter(t => t !== '+plugin/placeholder');
      if (followup && response.tags.find(t => t.startWith('plugin/delta/ai'))) {
        // Only allow one cycle of follow-ups
        response.tags = response.tags.filter(t => !t.startWith('plugin/delta/ai'));
      }
      response.sources = [...response.sources, ...(completionRef.sources || []).filter(uniq).filter(s => !sources.includes(s))];
      // TODO: Allow AI to add some protected tags
      const publicTagRegex = /^[a-z0-9]+(?:[./][a-z0-9]+)*$/;
      for (let i = 0; i < bundle.ref.length; i++) {
        const r = bundle.ref[i];
        if (i) {
          if (r.tags?.includes('dm')) r.tags.push('plugin/thread');
          if (r.tags?.includes('plugin/thread')) r.tags.push('internal');
          if (r.tags?.includes('plugin/comment')) r.tags.push('internal');
          r.tags = (r.tags || [])
            .filter(t => publicTagRegex.test(t) || t === '+plugin/delta/ai')
            .filter(uniq);
        }
        delete r.metadata;
        const oldUrl = i === 0 ? completionRef.url : r.url;
        // TODO: only replace comment: urls
        if (oldUrl && (oldUrl.startsWith('http:') || oldUrl.startsWith('https:'))) continue;
        const newUrl = i === 0 ? r.url : r.url = 'ai:' + uuid.v4();
        if (!oldUrl) continue;
        for (const rewrite of bundle.ref) {
          for (let i = 0; i < rewrite.sources?.length; i++) {
            if (rewrite.sources[i] === oldUrl) rewrite.sources[i] = newUrl;
          }
          if (rewrite.comment) {
            rewrite.comment = rewrite.comment
              .replaceAll('](' + oldUrl + ')', '](' + newUrl + ')')
              .replaceAll('](/ref/' + oldUrl + ')', '](/ref/' + newUrl + ')')
              .replaceAll('url=' + oldUrl, 'url=' + newUrl)
              .replaceAll('sources/' + oldUrl, 'sources/' + newUrl)
              .replaceAll('responses/' + oldUrl, 'responses/' + newUrl)
              .replaceAll('sources%2F' + oldUrl, 'sources%2F' + newUrl)
              .replaceAll('responses%2F' + oldUrl, 'responses%2F' + newUrl);
          }
        }
      }
      console.log(JSON.stringify(bundle));
    `,
    form: [{
      key: 'provider',
      type: 'select',
      props: {
        label: $localize`Provider:`,
        options: [
          { value: 'openai', label: $localize`OpenAI` },
          { value: 'anthropic', label: $localize`Anthropic` },
          { value: 'x', label: $localize`xAI` },
          { value: 'gemini', label: $localize`Gemini` },
          { value: 'ds', label: $localize`Deep Seek` },
        ],
      },
    }],
    advancedForm: [{
      key: 'audio',
      type: 'boolean',
      defaultValue: false,
      props: {
        label: $localize`Audio`,
      },
    }, {
      key: 'vision',
      type: 'boolean',
      defaultValue: false,
      props: {
        label: $localize`Vision`,
      },
    }, {
      key: 'apiKeyTag',
      type: 'tag',
      props: {
        label: $localize`🔑️ API Key Tag:`,
        prefix: '+plugin/secret',
      },
    }, {
      key: 'model',
      type: 'string',
      props: {
        label: $localize`Model:`,
      },
    }, {
      key: 'systemPrompt',
      type: 'textarea',
      props: {
        label: $localize`System Prompt:`,
      },
    }, {
      key: 'maxTokens',
      type: 'number',
      props: {
        label: $localize`Max Tokens:`,
      },
    }, {
      key: 'thinking',
      type: 'boolean',
      defaultValue: false,
      props: {
        label: $localize`Thinking`,
      },
    }, {
      key: 'thinkingTokens',
      type: 'number',
      props: {
        label: $localize`Thinking Tokens:`,
      },
    }, {
      key: 'maxContext',
      type: 'number',
      props: {
        label: $localize`Max Context:`,
      },
    }, {
      key: 'maxSources',
      type: 'number',
      props: {
        label: $localize`Max Sources:`,
      },
    }],
  },
  defaults: {
    provider: 'gemini',
    maxContext: 7,
    maxSources: 2000,
  },
  schema: {
    optionalProperties: {
      provider: { type: 'string' },
      apiKeyTag: { type: 'string' },
      model: { type: 'string' },
      audio: { type: 'boolean' },
      vision: { type: 'boolean' },
      maxTokens: { type: 'uint32' },
      thinking: { type: 'boolean' },
      thinkingTokens: { type: 'uint32' },
      maxContext: { type: 'uint32' },
      maxSources: { type: 'uint32' },
      systemPrompt: { type: 'string' },
    }
  }
};

export const aiPlugin: Plugin = {
  tag: '+plugin/delta/ai',
  name: $localize`✨️ AI Response`,
  config: {
    mod: $localize`✨️ AI Generation`,
    type: 'tool',
    default: false,
    generated: $localize`Generated by jasper-ui ${DateTime.now().toISO()}`,
    // language=Handlebars
    infoUi: `{{#if model}}<span style="user-select:none;cursor:zoom-in" title="{{model}}: {{usage.totalTokens}} ({{usage.promptTokens}} + {{usage.completionTokens}})">ℹ️ ({{provider}})</span>{{/if}}`,
  },
  schema: {
    optionalProperties: {
      provider: { type: 'string' },
      apiKeyTag: { type: 'string' },
      model: { type: 'string' },
      audio: { type: 'boolean' },
      vision: { type: 'boolean' },
      maxTokens: { type: 'uint32' },
      thinking: { type: 'boolean' },
      thinkingTokens: { type: 'uint32' },
      maxContext: { type: 'uint32' },
      maxSources: { type: 'uint32' },
      systemPrompt: { type: 'string' },
      usage: {
        optionalProperties: {
          promptTokens: { type: 'uint32' },
          completionTokens: { type: 'uint32' },
          totalTokens: { type: 'uint32' },
        }
      }
    },
  },
  generateMetadata: true,
};

export const aiMod: Mod = {
  plugin: [
    aiPlugin,
    aiQueryPlugin,
  ],
};
